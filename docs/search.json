[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Ahmed Mhedhbi",
    "section": "",
    "text": "Post With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nThursday, the 9th of January, 2025\n\n\nAhmed Mhedhbi\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nMonday, the 6th of January, 2025\n\n\nAhmed Mhedhbi\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "treeEvalPy.html",
    "href": "treeEvalPy.html",
    "title": "Tree Evaluation is in Space O(log n log log n) implementation",
    "section": "",
    "text": "TreeEval in Python\n\n\nCode\nimport galois\nimport math\nimport random\nimport copy\n\n\ndef reverse(lst, start, end):\n    while start &lt; end:\n        lst[start], lst[end] = lst[end], lst[start]\n        start += 1\n        end -= 1\n\n\ndef rotate_left_inplace(lst, shift=1):\n    n = len(lst)\n    shift %= n\n    if shift == 0:\n        return\n    reverse(lst, 0, shift - 1)\n    reverse(lst, shift, n - 1)\n    reverse(lst, 0, n - 1)\n\n\ndef e_poly(beta, y):\n    res = field(1)\n    for yi, betai in zip(beta, registers[y]):\n        res *= (field(1) - yi + (2 * yi - field(1)) * betai)\n    return res\n\n\ndef q_u_i(node, i):\n    res = field(0)\n    for alpha in range(k):\n        for beta in range(k):\n            for gamma in range(k):\n                alpha_bits = [field(int(bit)) for bit in f'{alpha:0{log_k}b}'[::-1]]\n                beta_bits  = [field(int(bit)) for bit in f'{beta:0{log_k}b}'[::-1]]\n                gamma_bits = [field(int(bit)) for bit in f'{gamma:0{log_k}b}'[::-1]]\n                if alpha_bits[i] == field(1) and tree[node][beta][gamma] == alpha:\n                    res += e_poly(beta_bits, 0) * e_poly(gamma_bits, 2)\n    return res\n\n\ndef recursive_clean(node):\n    if node &gt;= (1 &lt;&lt; height) - 1:\n        bits = [field(int(bit)) for bit in f'{tree[node]:0{log_k}b}'[::-1]]\n        for i, bit in enumerate(bits):\n            registers[2][i] += bit\n        return\n\n    left_child = 2 * node + 1\n    right_child = 2 * node + 2\n\n    for j in range(1, m + 1):\n        omega_j = omega ** j\n        for i in range(log_k):\n            registers[0][i] *= omega_j\n            registers[1][i] *= omega_j\n\n        rotate_left_inplace(registers)\n        recursive_clean(left_child)\n\n        registers[0], registers[2] = registers[2], registers[0]\n        recursive_clean(right_child)\n\n        for i in range(log_k):\n            registers[1][i] -= q_u_i(node, i)\n\n        registers[0], registers[2] = registers[2], registers[0]\n        recursive_clean_inverse(left_child)\n\n        registers[0], registers[2] = registers[2], registers[0]\n        recursive_clean_inverse(right_child)\n\n        rotate_left_inplace(registers, 2)\n        registers[0], registers[1] = registers[1], registers[0]\n\n        for i in range(log_k):\n            registers[0][i] /= omega_j\n            registers[1][i] /= omega_j\n\n\ndef recursive_clean_inverse(node):\n    if node &gt;= (1 &lt;&lt; height) - 1:\n        bits = [field(int(bit)) for bit in f'{tree[node]:0{log_k}b}'[::-1]]\n        for i, bit in enumerate(bits):\n            registers[2][i] -= bit\n        return\n\n    left_child = 2 * node + 1\n    right_child = 2 * node + 2\n\n    for j in range(1, m + 1):\n        omega_j = omega ** j\n        for i in range(log_k):\n            registers[0][i] *= omega_j\n            registers[1][i] *= omega_j\n\n        rotate_left_inplace(registers)\n        recursive_clean_inverse(left_child)\n        registers[0], registers[2] = registers[2], registers[0]\n        recursive_clean_inverse(right_child)\n        for i in range(log_k):\n            registers[1][i] += q_u_i(node, i)\n\n\n        registers[0], registers[2] = registers[2], registers[0]\n        recursive_clean(left_child)\n        registers[0], registers[2] = registers[2], registers[0]\n        recursive_clean(right_child)\n        rotate_left_inplace(registers, 2)\n        registers[0], registers[1] = registers[1], registers[0]\n        for i in range(log_k):\n            registers[0][i] /= omega_j\n            registers[1][i] /= omega_j\n\n\ndef clean_computation(h):\n    initial_registers = copy.deepcopy(registers)\n    recursive_clean(0)\n    res = 0\n    for i in range(log_k):\n        res += int(registers[2][i] - initial_registers[2][i]) * (2 ** i)\n    return res, registers\n\n\ndef initialize_field(k):\n    field_order = 1 &lt;&lt; math.ceil(math.log2(2 * math.ceil(math.log2(k)) + 2))\n    field = galois.GF(field_order)\n    return field, field_order\n\n\ndef initialize_tree_and_catalyst():\n    h = int(input(\"Enter the height of the tree: \"))\n    k = int(input(\"Enter the size of the alphabet: \"))\n    function = [[int(input(f\"Enter the value for function at row {r}, column {c}: \")) for c in range(k)]\n                for r in range(k)]\n\n    tree_functions = [function for _ in range((1 &lt;&lt; h) - 1)]\n\n    tree_values = [int(input(f\"Enter the value of leaf node {i}: \")) for i in range(1 &lt;&lt; h)]\n    tree = tree_functions + tree_values\n\n    log_k = math.ceil(math.log2(k + 1))\n\n    field, field_order = initialize_field(k)\n    registers = [[field(random.randint(0, field.order - 1)) for _ in range(log_k)] for _ in\n                 range(3)]\n\n    return h, k, tree, registers, field, field_order - 1\n\n\ndef naive_algorithm(node):\n    if node &gt;= (1 &lt;&lt; height) - 1:\n        return tree[node]\n\n    left = naive_algorithm(2 * node + 1)\n    right = naive_algorithm(2 * node + 2)\n\n    return tree[node][left][right]\n\nif __name__ == \"__main__\":\n    height, k, tree, registers, field, m = initialize_tree_and_catalyst()\n    log_k = math.ceil(math.log2(k + 1))\n    omega = field.primitive_element\n    registers_copy = copy.deepcopy(registers)\n    result, final_registers = clean_computation(height)\n\n    naive = naive_algorithm(0)\n\n    print(\"*\" * 80)\n    assert result == naive\n    print(f\"Tree evaluation result: {result}\")\n    print(f\"Initial registers:\\n{registers_copy}\")\n    print(f\"Final registers:\\n{final_registers}\")"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "slides.html#merci",
    "href": "slides.html#merci",
    "title": "Le chemin pour battre les programmes de branchement pour GEN",
    "section": "Merci !",
    "text": "Merci !"
  },
  {
    "objectID": "TreeEvalCpp.html",
    "href": "TreeEvalCpp.html",
    "title": "Tree Evaluation is in Space O(log n log log n) implementation",
    "section": "",
    "text": "TreeEval in CPP\n\n\nCode\n#include &lt;iostream&gt;\n#include &lt;cassert&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n#include &lt;ranges&gt;\n#include &lt;random&gt;\n\nusing namespace std;\n\n\nstruct GF_2;\n\n\nstruct FieldElement {\n    uint64_t value;\n    const GF_2* field;\n\n    FieldElement(uint64_t v, const GF_2* f);\n    FieldElement() : value(0), field(nullptr) {}\n\n    FieldElement operator+(const FieldElement& other) const;\n    FieldElement operator-(const FieldElement& other) const;\n    FieldElement operator*(const FieldElement& other) const;\n    FieldElement operator/(const FieldElement& other) const;\n    bool operator==(const FieldElement& other) const;\n};\n\n\nstruct GF_2 {\n    uint64_t n;                 // Field degree.\n    uint64_t poly;              // The irreducible polynomial for GF(2^m).\n    uint64_t omega;             // The generator element.\n    uint64_t fieldSize;         // 2^n\n    uint64_t m;                 // fieldSize - 1\n\n    [[nodiscard]] explicit GF_2(const uint64_t n) : n(n){\n        fieldSize = 1ULL &lt;&lt; n;\n        m = fieldSize - 1;\n\n        omega = 2; // if the irreducible polynomial is primitive\n        switch (n) { // trinomial polynomials (3 elements) to accelerate the code not all of them though\n            case 2: poly = 07; break;\n            case 3: poly = 013; break;\n            case 4: poly = 023; break;\n            case 5: poly = 045; break;\n            case 6: poly = 0103; break;\n            case 7: poly = 0203; break;\n            case 8: poly = 0435; break;\n            case 9: poly = 01021; break;\n            case 10: poly = 02011; break;\n            case 11: poly = 04005; break;\n            case 12: poly = 010123; break;\n            case 13: poly = 020033; break;\n            case 14: poly = 042103; break;\n            case 15: poly = 0100003; break;\n            case 16: poly = 0210013; break;\n            case 17: poly = 0400011; break;\n            case 18: poly = 01000201; break;\n            case 19: poly = 02000047; break;\n            case 20: poly = 04000011; break;\n            case 21: poly = 010000005; break;\n            case 22: poly = 020000003; break;\n            case 23: poly = 040000041; break;\n            case 24: poly = 0100000207; break;\n            case 25: poly = 0200000011; break;\n            case 26: poly = 0400000107; break;\n            case 27: poly = 01000000047; break;\n            case 28: poly = 02000000011; break;\n            case 29: poly = 04000000005; break;\n            case 30: poly = 010040000007; break;\n            case 31: poly = 020000000011; break;\n            case 32: poly = 040020000007; break;\n            default: throw invalid_argument(\"Unsupported for now\");\n        }\n    }\n\n    [[nodiscard]] uint64_t reduce(uint64_t x) const {\n        if (x == 0) return 0;\n        while(x &gt;= fieldSize) {\n            // __builtin_clzll returns the number of leading zeros in a 64-bit integer.\n            auto const shift = 64 - __builtin_clzll(x) - n;\n            x ^= (poly &lt;&lt; shift);\n        }\n        return x;\n    }\n\n    [[nodiscard]] static uint64_t add(const uint64_t x, const uint64_t y) {\n        return x ^ y; // xor\n    }\n\n    [[nodiscard]] uint64_t mul(uint64_t x, uint64_t y) const { // à la russe\n        uint64_t z = 0;\n        while (x &gt; 0) {\n            if (x & 1) {\n                z ^= y;\n            }\n            x &gt;&gt;= 1;\n            y &lt;&lt;= 1;\n            if (y & fieldSize) {\n                y ^= poly;\n            }\n        }\n        return z;\n    }\n\n    [[nodiscard]] uint64_t powGF(uint64_t x, uint64_t exp) const {\n        uint64_t result = 1;\n        exp %= m;\n\n        while (exp &gt; 0) {\n            if (exp & 1)\n                result = mul(result, x);\n            x = mul(x, x);\n            exp &gt;&gt;= 1;\n        }\n        return result;\n    }\n\n     [[nodiscard]] uint64_t inv(const uint64_t x) const {\n        if (x == 0)\n            throw invalid_argument(\"zero is not invertible\");\n        return powGF(x, fieldSize - 2); // th de Fermat\n    }\n};\n\n\nFieldElement::FieldElement(uint64_t v, const GF_2* f) : field(f) {\n    if (!f) throw invalid_argument(\"Field pointer cannot be null\");\n    if (v &gt;= f-&gt;fieldSize)\n        throw invalid_argument(\"Element exceeds field size\");\n    value = v;\n}\n\n\nFieldElement FieldElement::operator+(const FieldElement& other) const {\n    if (field != other.field)\n        throw invalid_argument(\"Field mismatch in addition\");\n    return { GF_2::add(value, other.value), field };\n}\n\n\nFieldElement FieldElement::operator-(const FieldElement& other) const {\n    return *this + other;\n}\n\n\nFieldElement FieldElement::operator*(const FieldElement& other) const {\n    if (field != other.field)\n        throw invalid_argument(\"Field mismatch in multiplication\");\n    return {FieldElement(field-&gt;mul(value, other.value), field)};\n}\n\nFieldElement FieldElement::operator/(const FieldElement& other) const {\n    if (field != other.field)\n        throw invalid_argument(\"Field mismatch in division\");\n    const uint64_t inv_val = field-&gt;inv(other.value);\n    return {FieldElement(field-&gt;mul(value, inv_val), field)};\n}\n\nbool FieldElement::operator==(const FieldElement& other) const {\n    return field == other.field && value == other.value;\n}\n\n\nstruct algorithm_parameters {\n    uint64_t h;\n    uint64_t k;\n    vector&lt;vector&lt;FieldElement&gt;&gt; f_u;\n    vector&lt;vector&lt;vector&lt;FieldElement&gt;&gt;&gt; tree_functions;\n    vector&lt;FieldElement&gt; tree_leaves;\n    GF_2* field;\n    vector&lt;vector&lt;FieldElement&gt;&gt; registers;\n    uint64_t u;\n    uint64_t log_k;\n};\n\n\nGF_2* initialize_field(const uint64_t k) {\n    uint64_t field_degree = ceil(log2(2 * ceil(log2(k)) + 2));\n    auto const f = new GF_2(field_degree);\n    return f;\n}\n\n\nalgorithm_parameters algorithm_parameters_init() {\n    algorithm_parameters params;\n    cout &lt;&lt; \"Enter the height of the tree: \";\n    cin &gt;&gt; params.h;\n    cout &lt;&lt; \"Enter the size of the alphabet (k): \";\n    cin &gt;&gt; params.k;\n\n    uint64_t h = params.h;\n    uint64_t k = params.k;\n\n    params.field = initialize_field(k);\n    vector f_u(k, vector&lt;FieldElement&gt;(k));\n    cout &lt;&lt; \"Enter the values for the function matrix:\" &lt;&lt; endl;\n    for (uint64_t i = 0; i &lt; k; i++) {\n        for (uint64_t j = 0; j &lt; k; j++) {\n            uint64_t val;\n            cout &lt;&lt; \"Row \" &lt;&lt; i &lt;&lt; \", Column \" &lt;&lt; j &lt;&lt; \": \";\n            cin &gt;&gt; val;\n            f_u[i][j] = FieldElement(val, params.field);\n        }\n    }\n\n    params.f_u = f_u;\n\n    params.tree_functions.resize((1ULL &lt;&lt; h) - 1, f_u);\n    params.tree_leaves.resize(1ULL &lt;&lt; h, FieldElement(0, params.field));\n    cout &lt;&lt; \"Enter the value for each leaf node:\" &lt;&lt; endl;\n    for (uint64_t i = 0; i &lt; (1ULL &lt;&lt; h); i++) {\n        uint64_t leaf_val;\n        cout &lt;&lt; \"Leaf node \" &lt;&lt; i &lt;&lt; \": \";\n        cin &gt;&gt; leaf_val;\n        params.tree_leaves[i] = FieldElement(leaf_val, params.field);\n    }\n\n    uint64_t log_k = ceil(log2(k + 1));\n    params.log_k = log_k;\n\n    params.registers.resize(3);\n    for (int r = 0; r &lt; 3; r++) {\n        params.registers[r].resize(log_k);\n        for (uint64_t i = 0; i &lt; log_k; i++) {\n            params.registers[r][i] = FieldElement(rand() % params.field-&gt;fieldSize, params.field);\n        }\n    }\n\n    params.u = 0;\n    return params;\n}\n\n\nalgorithm_parameters algo = algorithm_parameters_init();\n\nvector&lt;FieldElement&gt; get_bit_vector(uint64_t x) {\n    vector&lt;FieldElement&gt; bits;\n    bits.reserve(algo.log_k);\n    for (uint64_t i = 0; i &lt; algo.log_k; ++i) {\n        bits.emplace_back((x &gt;&gt; i) & 1ULL, algo.field);\n    }\n    return bits;\n}\n\nFieldElement e_poly(int r, const vector&lt;FieldElement&gt;& beta) {\n    FieldElement res(1, algo.field);\n    FieldElement one(1, algo.field);\n    for (uint64_t i = 0; i &lt; algo.log_k; ++i) {\n        res = res * (one - algo.registers[r][i] + (algo.registers[r][i] + algo.registers[r][i] - one) * beta[i]);\n    }\n    return res;\n}\n\n\nFieldElement q_u_i(const uint64_t node, const int i) {\n    FieldElement res(0, algo.field);\n    for (uint64_t alpha = 0; alpha &lt; algo.k; ++alpha) {\n        if (((alpha &gt;&gt; i) & 1ULL) != 1)\n            continue;\n        for (uint64_t beta = 0; beta &lt; algo.k; ++beta) {\n            for (uint64_t gamma = 0; gamma &lt; algo.k; ++gamma) {\n                if (algo.tree_functions[node][beta][gamma].value == alpha) {\n                    vector&lt;FieldElement&gt; beta_bits = get_bit_vector(beta);\n                    vector&lt;FieldElement&gt; gamma_bits = get_bit_vector(gamma);\n                    res = res + (e_poly(0, beta_bits) * e_poly(2, gamma_bits));\n                }\n            }\n        }\n    }\n    return res;\n}\n\n\nvoid recursive_clean_inverse(uint64_t h);\n\n\nvoid recursive_clean(uint64_t h) {\n    if (h == 0) {\n        uint64_t leaf_index = algo.u - ((1ULL &lt;&lt; algo.h) - 1);\n        for (uint64_t i = 0; i &lt; algo.log_k; ++i) {\n            const uint64_t bit = (algo.tree_leaves[leaf_index].value &gt;&gt; i) & 1ULL;\n            algo.registers[2][i] = algo.registers[2][i] + FieldElement(bit, algo.field);\n        }\n        return;\n    }\n\n    for (int j = 1; j &lt;= algo.field-&gt;m; ++j) {\n        auto w_j = FieldElement(algo.field-&gt;powGF(algo.field-&gt;omega, j), algo.field);\n\n        for (int i = 0; i &lt; algo.log_k; ++i) {\n            algo.registers[0][i] = algo.registers[0][i] * w_j;\n            algo.registers[1][i] = algo.registers[1][i] * w_j;\n        }\n\n        ranges::rotate(algo.registers, algo.registers.begin() + 1);\n\n        algo.u = 2 * algo.u + 1;\n\n        recursive_clean(h - 1);\n\n        swap(algo.registers[0], algo.registers[2]);\n\n        algo.u += 1;\n\n        recursive_clean(h - 1);\n\n        for (int i = 0; i &lt; algo.log_k; ++i) {\n            algo.registers[1][i] = algo.registers[1][i] - q_u_i((algo.u - 1) / 2, i);\n        }\n\n        swap(algo.registers[0], algo.registers[2]);\n\n        algo.u -= 1;\n        recursive_clean_inverse(h - 1);\n\n        swap(algo.registers[0], algo.registers[2]);\n\n        algo.u += 1;\n\n        recursive_clean_inverse(h - 1);\n\n        algo.u = (algo.u - 1) / 2;\n        ranges::rotate(algo.registers, algo.registers.begin() + 2);\n        swap(algo.registers[0], algo.registers[1]);\n\n        for (int i = 0; i &lt; algo.log_k; ++i) {\n            algo.registers[0][i] = algo.registers[0][i] / w_j;\n            algo.registers[1][i] = algo.registers[1][i] / w_j;\n        }\n    }\n}\n\nvoid recursive_clean_inverse(uint64_t h) {\n    if (h == 0) {\n        uint64_t leaf_index = algo.u - ((1ULL &lt;&lt; algo.h) - 1);\n        for (uint64_t i = 0; i &lt; algo.log_k; ++i) {\n            const uint64_t bit = (algo.tree_leaves[leaf_index].value &gt;&gt; i) & 1ULL;\n            algo.registers[2][i] = algo.registers[2][i] - FieldElement(bit, algo.field);\n        }\n        return;\n    }\n\n    for (int j = 1; j &lt;= algo.field-&gt;m; ++j) {\n        auto w_j = FieldElement(algo.field-&gt;powGF(algo.field-&gt;omega, j), algo.field);\n\n        for (int i = 0; i &lt; algo.log_k; ++i) {\n            algo.registers[0][i] = algo.registers[0][i] * w_j;\n            algo.registers[1][i] = algo.registers[1][i] * w_j;\n        }\n\n        ranges::rotate(algo.registers, algo.registers.begin() + 1);\n\n        algo.u = 2 * algo.u + 1;\n\n        recursive_clean_inverse(h - 1);\n\n        swap(algo.registers[0], algo.registers[2]);\n\n        algo.u += 1;\n\n        recursive_clean_inverse(h - 1);\n\n        for (int i = 0; i &lt; algo.log_k; ++i) {\n            algo.registers[1][i] = algo.registers[1][i] + q_u_i((algo.u - 1) / 2, i);\n        }\n\n        swap(algo.registers[0], algo.registers[2]);\n\n        algo.u -= 1;\n        recursive_clean(h - 1);\n\n        swap(algo.registers[0], algo.registers[2]);\n\n        algo.u += 1;\n\n        recursive_clean(h - 1);\n\n        algo.u = (algo.u - 1) / 2;\n        ranges::rotate(algo.registers, algo.registers.begin() + 2);\n        swap(algo.registers[0], algo.registers[1]);\n\n        for (int i = 0; i &lt; algo.log_k; ++i) {\n            algo.registers[0][i] = algo.registers[0][i] / w_j;\n            algo.registers[1][i] = algo.registers[1][i] / w_j;\n        }\n    }\n}\n\nuint64_t clean_computation(uint64_t h) {\n    auto registers_copy = algo.registers;\n\n    recursive_clean(h);\n\n    vector&lt;FieldElement&gt; diff;\n    uint64_t res = 0;\n\n    diff.resize(algo.log_k);\n\n    for (uint64_t i = 0; i &lt; algo.log_k; i++) {\n        assert(algo.registers[0][i].value == registers_copy[0][i].value);\n        assert(algo.registers[1][i].value == registers_copy[1][i].value);\n        res += (algo.registers[2][i] - registers_copy[2][i]).value * (1 &lt;&lt; i);\n    }\n\n    return res;\n}\n\nFieldElement naive_algorithm(uint64_t node, uint64_t level) {\n    if (level == algo.h) {\n        const uint64_t leaf_index = node - ((1ULL &lt;&lt; algo.h) - 1);\n        return algo.tree_leaves[leaf_index];\n    }\n\n    FieldElement left = naive_algorithm(2 * node + 1, level + 1);\n    FieldElement right = naive_algorithm(2 * node + 2, level + 1);\n    return algo.tree_functions[node][left.value][right.value];\n}\n\n\nint main() {\n    const uint64_t h = algo.h;\n    const uint64_t result = clean_computation(h);\n\n    const auto naive = naive_algorithm(0, 0);\n\n    assert(result == naive.value && \"Result does not match the naive evaluation!!!!!\");\n    cout &lt;&lt; \"Tree evaluation result: \" &lt;&lt; result &lt;&lt; endl;\n    return 0;\n}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ahmed Mhedhbi",
    "section": "",
    "text": "On a quest for knowledge …"
  },
  {
    "objectID": "projetHonor.html",
    "href": "projetHonor.html",
    "title": "Projet Honor",
    "section": "",
    "text": "Voici la description du projet."
  },
  {
    "objectID": "projetHonor.html#janvier---26-janvier",
    "href": "projetHonor.html#janvier---26-janvier",
    "title": "Projet Honor",
    "section": "13 Janvier - 26 Janvier",
    "text": "13 Janvier - 26 Janvier\n\n\nTâches\n\n\nLire les papiers [BCK+14] et [M23] (“Reuse Space” par Mertz)."
  },
  {
    "objectID": "projetHonor.html#january---9-février",
    "href": "projetHonor.html#january---9-février",
    "title": "Projet Honor",
    "section": "27 January - 9 Février",
    "text": "27 January - 9 Février\n\n\nTâches\n\n\nRelire [BCK+14] et faire les exercices de [M23].\nLire [CM24]\nFaire le circuit Pour GEN."
  },
  {
    "objectID": "projetHonor.html#février---23-février",
    "href": "projetHonor.html#février---23-février",
    "title": "Projet Honor",
    "section": "9 Février - 23 Février",
    "text": "9 Février - 23 Février\n\n\nTâches\n\n\nRédiger un document détaillé pour le circuit destiné à GEN, en démontrant aussi que le problème est P-complet (comme un exercice).\nRéaliser une rétro-ingénierie de TreeEval afin d’appliquer ses méthodes sur GEN.\nLire Modern C par Jens Gustedt (3ème édition) pour refaire l’implémentation de TreeEval catalytique en C."
  },
  {
    "objectID": "projetHonor.html#février---9-mars",
    "href": "projetHonor.html#février---9-mars",
    "title": "Projet Honor",
    "section": "23 Février - 9 Mars",
    "text": "23 Février - 9 Mars\n\n\nTâches\n\n\nLire le papier d’Oded Goldreich, `` On the Cook-Mertz Tree Evaluation Procedure”.\nRevoir le plan et opter finalement pour une implémentation en C++ (sinon le code serait difficile à manipuler pour les corps algèbriques)."
  },
  {
    "objectID": "projetHonor.html#mars---23-mars",
    "href": "projetHonor.html#mars---23-mars",
    "title": "Projet Honor",
    "section": "10 Mars - 23 Mars",
    "text": "10 Mars - 23 Mars\n\n\nTâches\n\n\nÉtudier le papier d’Oded Goldreich, “Solving Tree Evaluation in \\(\\cal{o}(\\log n \\cdot log log n)\\) Space” (ce qui ne semble pas vraiment utile pour le projet après tout).\nessayer de rafiner l’implementation l’algo de TreeEval en python."
  },
  {
    "objectID": "projetHonor.html#mars---6-avril",
    "href": "projetHonor.html#mars---6-avril",
    "title": "Projet Honor",
    "section": "24 Mars - 6 Avril",
    "text": "24 Mars - 6 Avril\n\n\nTâches\n\n\nFaire une passe le papier “Simulating Time With Square-Root Space*” (à finir la semaine prochaine).\nFinaliser l’implémentation de l’algorithme TreeEval en C++ (qui est déjà terminée et fonctionne comme prévu).\nS’approcher d’une solution pour GEN, qui pourrait être pertinente (par contre, il me manque un petit détail qui peut être aussi un grand détail)."
  },
  {
    "objectID": "projetHonor.html#avril---20-avril",
    "href": "projetHonor.html#avril---20-avril",
    "title": "Projet Honor",
    "section": "7 Avril - 20 Avril",
    "text": "7 Avril - 20 Avril\n\n\nTâches\n\n\nRaffiner l’implémentation de l’algorithme TreeEval en C++."
  },
  {
    "objectID": "projetHonor.html#avril---2-mai",
    "href": "projetHonor.html#avril---2-mai",
    "title": "Projet Honor",
    "section": "21 Avril - 2 Mai",
    "text": "21 Avril - 2 Mai\n\n\nTâches\n\n\nFinaliser la rédaction du rapport."
  }
]